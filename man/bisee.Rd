% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bisee.R, R/gsee.R, R/see.R
\name{bisee}
\alias{bisee}
\alias{bisee.default}
\alias{bisee.fit}
\alias{bisee.formula}
\alias{gsee}
\alias{see}
\title{Bi-level Stagewise Estimating Equations Implementation}
\usage{
bisee(y, ...)

\method{bisee}{formula}(formula, data = list(), clusterID, waves = NULL,
  lambda1, lambda2, contrasts = NULL, subset, ...)

\method{bisee}{default}(y, x, waves = NULL, lambda1, lambda2, ...)

\method{bisee}{fit}(y, x, family, clusterID, waves = NULL, groupID,
  corstr = "independence", alpha = NULL, lambda1 = 0.5, lambda2 = 1 -
  lambda1, intercept = TRUE, offset = 0, control = sgee.control(maxIt =
  200, epsilon = 0.05, stoppingThreshold = min(nrow(y), ncol(x)) - intercept),
  standardize = TRUE, ...)

gsee(y, x, family, clusterID, waves = NULL, groupID = 1:ncol(x),
  corstr = "independence", alpha = NULL, offset = 0, intercept = TRUE,
  control = sgee.control(maxIt = 200, epsilon = 0.05, stoppingThreshold =
  min(nrow(y), ncol(x)) - intercept), standardize = TRUE, ...)

see(y, x, family, clusterID, waves = NULL, corstr = "independence",
  alpha = NULL, intercept = TRUE, offset = 0,
  control = sgee.control(maxIt = 200, epsilon = 0.05, stoppingThreshold =
  min(nrow(y), ncol(x)) - intercept), standardize = TRUE, ...)
}
\arguments{
\item{y}{Vector of response measures that corresponds with modeling family
given in 'family' parameter. \code{y} is assumed to be the same length as
\code{clusterID} and is assumed to be organized into clusters as dictated by
\code{clusterID}.}

\item{...}{Not currently used}

\item{formula}{Object of class 'formula'; a symbolic description of
the model to be fitted}

\item{data}{Optional data frame containing the variables in the model.}

\item{clusterID}{Vector of integers that identifies the clusters of response
measures in \code{y}. Data and \code{clusterID} are assumed to
1) be of equal lengths,
2) sorted so that observations of a cluster are in contiguous rows, and 3)
organized so that \code{clusterID} is a vector of consecutive integers.}

\item{waves}{An integer vector which identifies components in clusters.
The length of \code{waves} should be the same as the number of
observations. \code{waves} is automatically generated if none is supplied,
but when using \code{subset} parameter, the \code{waves} parameter must be
provided by the user for proper calculation.}

\item{lambda1}{Mixing parameter used to indicate weight of $L_1$ Norm
(individual selection). While not necessary, \code{lambda1} and
\code{lambda2} are
best set to sum to 1 as only the weights relative to each other matter.
Default value is set to .5.}

\item{lambda2}{Mixing parameter used to indicate weight of $L_2$ Norm (group
selection). While not necessary, \code{lambda1} and
\code{lambda2} are best set to sum
to 1 as only the weights relative to each other matter.  Default value is
set to \code{1-lambda1}.}

\item{contrasts}{An optional list provided when using a formula.
similar to \code{contrasts} from \code{glm}.
See the \code{contrasts.arg} of \code{model.matrix.default}.}

\item{subset}{An optional vector specifying a subset of observations to be
used in the fitting process.}

\item{x}{Design matrix of dimension \code{length(y)} x nvar,
the number of variables, where each row is
represents an obersvation of predictor variables. Assumed to be scaled.}

\item{family}{Modeling family that describes the marginal distribution of
the response. Assumed to be an object such as \code{gaussian()} or
\code{poisson()}.}

\item{groupID}{Vector of integeres that identifies the groups of the
covariates/coefficients (i.e. the columns of \code{x}).  \code{x}
and \code{groupID} are
assumed 1) to be of corresponding dimension, (i.e.
\code{ncol(x) == length(groupID)}),
2) sorted so that groups of covariates are in contiguous
columns, and 3) organized so that \code{groupID} is a vector of consecutive
integers.}

\item{corstr}{A character string indicating the desired working correlation
structure. The following are implemented : "independence" (default value),
"exchangeable", and "ar1".}

\item{alpha}{An intial guess for the correlation parameter value
between -1 and 1 . If left NULL (the default), the initial estimate is 0.}

\item{intercept}{Binary value indicating where an intercept term is
to be included in the model for estimation. Default is to include an
intercept.}

\item{offset}{Vector of offset value(s) for the linear predictor.
\code{offset}
is assumed to be either of length one, or of the same length as \code{y}.
Default is to have no offset.}

\item{control}{A list of parameters used to contorl the path generation
process; see \code{sgee.control}.}

\item{standardize}{A logical parameter that indicates whether or not
the covariates need to be standardized before fitting.
If standardized before fitting, the unstandardized
path is returned as the default, with a \code{standardizedPath} and
\code{standardizedX} included
separately. Default value is \code{TRUE}.}
}
\value{
Object of class \code{sgee} containing the path
of coefficient estimates,
the path of scale estimates, the path of correlation parameter
estimates, the iteration at which BiSEE terminated, and intial regression
values including \code{x}, \code{y}, code{family}, \code{clusterID},
\code{groupID}, \code{offset}, \code{epsilon}, and \code{numIt}.
}
\description{
Function to perform BiSEE, a Bi-Level Boosting / Functional
Gradient Descent / Forward Stagewise regression in
the grouped covariates setting using
Generalized Estimating Equations
}
\details{
Function to implement BiSEE, a stagewise regression approach
that is designed to perform bi-level selection in the context of
Generalized Estimating Equations. Given a response \code{y} and
a design matrix \code{x}
(excluding intercept) BiSEE generates a path of stagewise regression
estimates for each covariate based on the provided step size epsilon,
and tuning parameters \code{lambda1} and \code{lambda2}. When
\code{lambda1 == 0} or \code{lambda2 == 0}, the simplified versions
of \code{bisee} called \code{see} and \code{gsee}, respectively,
will be called.

The resulting path can then be analyzed to determine an optimal
model along the path of coefficient estimates. The
\code{summary.sgee} function provides such
functionality based on various
possible metrics, primarily focused on the Mean Squared Error.
Furthermore, the \code{plot.sgee} function can be used to examine the
path of coefficient estimates versus the iteration number, or some
desired penalty.

\code{bisee} makes use of the function uniroot in the stats package.
The \code{extendInt} parameter for \code{uniroot} is used, which may
cause issues for older versions of R.
}
\note{
Function to execute BiSEE technique. Note that \code{lambda1}
and \code{lambda2} are tuning parameters. Though it is advised to
fix \code{lambda1 + lambda2 = 1}, this is not necessary. These parameters
can be tuned using various approaches including cross validation.
}
\examples{


#####################
## Generate test data
#####################

## Initialize covariate values
p <- 50 
beta <- c(rep(2,5),
          c(1, 0, 1.5, 0, .5),
          rep(0.5,5),
          rep(0,p-15))
groupSize <- 5
numGroups <- length(beta)/groupSize


generatedData <- genData(numClusters = 50,
                         clusterSize = 4,
                         clusterRho = 0.6,
                         clusterCorstr = "exchangeable",
                         yVariance = 1,
                         xVariance = 1,
                         numGroups = numGroups,
                         groupSize = groupSize,
                         groupRho = 0.3,
                         beta = beta,
                         family = gaussian(),
                         intercept = 1)


## Perform Fitting by providing y and x values
coefMat1 <- bisee(y = generatedData$y, x = generatedData$x,
                 family = gaussian(),
                 clusterID = generatedData$clusterID,
                 groupID = generatedData$groupID, 
                 corstr = "exchangeable", 
                 control = sgee.control(maxIt = 50, epsilon = 0.5),
                 lambda1 = .5,
                 lambda2 = .5)


## Perform Fitting by providing formula and data
genDF <- data.frame(generatedData$y, generatedData$x)
names(genDF) <- c("Y", paste0("Cov", 1:p))
coefMat2 <- bisee(formula(genDF), data = genDF,
                 family = gaussian(),
                 subset = Y <1,
                 waves = rep(1:4, 50), 
                 clusterID = generatedData$clusterID,
                 groupID = generatedData$groupID, 
                 corstr = "exchangeable",
                 control = sgee.control(maxIt = 50, epsilon = 0.5),
                 lambda1 = 0,
                 lambda2 = 0.5)

par(mfrow = c(2,1))
plot(coefMat1)
plot(coefMat2)

}
\author{
Gregory Vaughan
}
\references{
G. Vaughan, R. Aseltine, K. Chen & J. Yan (2016). Stagewise
Generalized Estimating Equations with Grouped Variables. Department of
Statistics, University of Connecticut. Technical Report 16-09.

Wolfson, J. (2011). EEBoost: A general method for prediction
and variable selection based on estimating equations. Journal of the
American Statistical Association 106, 296--305.

Tibshirani, R. J. (2015). A general framework for fast stagewise
algorithms. Journal of Machine Learning Research 16, 2543--2588.

Simon, N., Friedman, J., Hastie, T., and Tibshirani, R. (2013). A
sparse-group lasso. Journal of Computational and Graphical
Statistics 22, 231--245.
}

